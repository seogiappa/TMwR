# A tidyverse 첫 번째 {#tidyverse}

```{r tidyverse-setup, include = FALSE}
knitr::opts_chunk$set(fig.path = "figures/")
library(tidyverse)
library(lubridate)
```

tidyverse는 일반적인 아이디어와 규범으로 개발된 데이터 분석을 위한 R 패키지 모음입니다. @tidyverse에 다음과 같은 문구가 있습니다.: 

> "높은 수준에서, tidyverse는 R 코드로 데이터 과학 문제를 해결하기 위한 언어입니다. 주요 목표는 데이터에 대한 인간과 컴퓨터 간의 대화를 촉진하는 것입니다. 좀 더 구체적으로 말하면, tidyverse는 높은 수준의 디자인 철학과 낮은 수준의 문법 및 데이터 구조를 공유하는 R 패키지 모음이므로 한 패키지를 배우면 다음 패키지를 더 쉽게 배울 수 있습니다."

이 장에서 우리는 이 원칙들과 이 원칙들이 모델링의 맥락에서 어떻게 적용되는지에 대해 간략하게 논의한 후, tidyverse 구문의 특정 예를 살펴봅니다.

## 원칙

tidyverse 스타일로 R 코드를 작성하기 위한 전체 전략 및 전술은 웹사이트 [`https://design.tidyverse.org`](https://design.tidyverse.org/)에서 찾을 수 있습니다. 여기에서는 몇 가지 디자인 원칙과 그 동기 및 모델링을 이러한 원칙에 적용하는 방법에 대해 간략히 설명합니다.

### 사람을 위한 디자인

tidyverse는 다양한 분야의 사람들이 쉽게 이해하고 사용할 수 있는 R 패키지 및 기능을 설계하는 데 초점을 맞춥니다. 과거 뿐아니라 오늘날에도 R 사용자의 상당수는 소프트웨어나 도구를 만드는 사람이 아니라 분석이나 모델을 만드는 사람들입니다. 따라서 R 사용자는 일반적으로 컴퓨터 과학의 배경이 없거나 필요하지 않으며, 또한 사용자가 자신의 R 패키지를 작성하는 데 관심이 없습니다.

이러한 이유로 R 코드를 쉽게 사용하여 목표를 달성하는 것이 중요합니다. 이를 위해 문서화, 교육, 접근성 및 기타 요소가 중요한 역할을 합니다. 구문 자체가 사람들이 쉽게 이해하기 어렵다면 문서화는 미흡한 해결책입니다. 따라서 소프트웨어 자체는 직관적이어야 합니다.

tidyverse의 접근 방식을 보다 전통적인 R의 의미 체계와 대조하기 위해 데이터 프레임 정렬을 고려해 봅시다. R의 핵심 언어만 사용해서, `order()`(벡터의 인덱스를 정렬된 순서로 반환하는 함수)와 함께 R의 첨자 규칙(subscripting rules; R의 자료 구조인 vector, matrix, array, data frame 등에서 원소를 표시하는 규칙-번역자)을 통해 행을 재정렬함으로써 하나 이상의 열에 대해 데이터 프레임을 정렬할 수 있습니다; 그런데, `sort()`라는 이름 때문에 이러한 상황에서 시도하고 싶은 함수를 성공적으로 사용할 수 _없습니다_. 두 개의 열을 기준으로 mtcars 데이터를 정렬하려면 다음과 같이 호출할 수 있습니다.

```{r tidyverse-base-sort, eval = FALSE}
mtcars[order(mtcars$gear, mtcars$mpg), ]
```

이 방법이 계산적으로 매우 효율적이지만 이것이 직관적인 사용자 인터페이스라고 주장하기는 어려울 것입니다. 반면에 `r pkg(dplyr)`의 tidyverse 함수 `arrange()`는 변수 이름 세트를 직접 입력 인수로 사용합니다.:

```{r tidyverse-dplyr-sort, eval = FALSE}
library(dplyr)
arrange(.data = mtcars, gear, mpg)
```

:::rmdnote
여기서 사용되는 변수 이름에는 따옴표("")가 없습니다.; 대부분의 전통적인 R 함수는 변수를 지정하기 위해 문자열이 필요하지만, tidyverse 함수는 따옴표가 없는 이름이나 _선택기 함수(selector function)_ 를 사용합니다. 선택기는 열 이름에 적용되어서 하나 이상의 읽기 가능한 규칙을 허용합니다. 예를 들어 ends_with("t")를 사용하면 mtcars 데이터 프레임의 drat 및 wt 열을 선택할 수 있습니다.
:::

또한 이름 지정이 중요합니다. R을 처음 사용하면서 선형 대수와 관련된 데이터 분석 또는 모델링 코드를 작성하는 경우 역행렬을 계산하는 함수를 검색할 때 어려움을 겪을 수 있습니다. `apropos('inv')`를 사용해도 알 수가 없습니다(apropos('inv')는 검색 목록의 개체 이름('inv')과 (정규 표현식으로) 일치하는 문자 벡터를 반환). 역행렬을 계산하는 기본 R 함수는 선형 방정식 시스템을 풀기 위한 `solve()` 함수입니다. 행렬 `X`의 경우 `solve(X)`를 사용하여 `X`의 역행렬을 구할 수 있습니다(방정식의 오른쪽에 벡터가 없음). 이것은 오로지 도움말 파일의 _arguments_ 중 하나에 대한 설명에만 설명되어 있습니다. 본질적으로 솔루션을 찾으려면 솔루션의 이름을 알아야 합니다.

tidyverse 접근 방식은 짧고 암시적인 함수 이름보다 설명적이고 명시적인 함수 이름을 사용하는 것입니다. 일반적으로 동사(예: 'fit', 'arrange' 등)에 초점이 맞춰져 있습니다. 동사-명사 쌍이 특히 효과적입니다.; 'invert_matrix()'라는 가상의 함수 이름을 생각해 보십시오. 모델링의 경우 그리스 문자나 모호한 용어와 같은 이름에서 고도로 기술적인 전문 용어를 사용하지 않는 것도 중요합니다. 이름은 가능한 한 자체 문서가 될 수 있어야 합니다.

패키지에 유사한 기능이 있는 경우 탭 완성에 최적화되도록 기능 이름이 설계되어 있습니다. 예를 들어 `r pkg(glue)` 패키지에는 공통 접두사(`glue_`)로 시작하는 함수 모음이 있어 사용자가 원하는 기능을 빠르게 찾을 수 있습니다.


### 기존 데이터 구조 재사용

가능하면 함수는 새로운 데이터 구조를 반환하지 않아야 합니다. 그 결과가 기존 데이터 구조에 도움이 되는 경우 이를 사용해야 합니다. 그래야 소프트웨어를 사용할 때 인지 부하를 줄여줍니다.; 추가 구문이나 메서드가 필요하지 않습니다.

tidyverse 및 tidymodels 패키지에서 가장 많이 사용되는 데이터 구조 중 하나는 데이터 프레임입니다. 데이터 프레임은 각 열에 다양한 데이터 유형과 각 행에 여러 값을 나타낼 수 있습니다. 아래에 설명된 데이터 프레임 유형인 Tibbles는 데이터 분석에 도움이 되는 추가 속성이 있기 때문에 선호됩니다.

예를 들어 `r pkg(rsample)` 패키지를 사용하여 교차 검증 또는 부트스트랩(`https://rsample.tidymodels.org/reference/bootstraps.html` 참조)과 같은 데이터 세트의 _리샘플_ 을 생성할 수 있습니다(@ref(리샘플링) 장에서 설명). 리샘플링 함수는 리샘플링된 데이터 세트를 정의하는 객체의 `분할`이라는 열을 가진 tibble을 반환합니다. mtcars 데이터 세트를 이용해 만든 세 개의 부트스트랩 샘플은 다음과 같습니다:

```{r tidyverse-resample}
boot_samp <- rsample::bootstraps(mtcars, times = 3)
boot_samp
class(boot_samp)
```

이 접근 방식을 사용하면 `vapply()` 또는 `purrr::map()`^[If you've never seen `::` in R code before, it is an explicit method for calling a function. The value of the left-hand side is the _namespace_ where the function lives (usually a package name). The right-hand side is the function name. In cases where two packages use the same function name, this syntax ensures that the correct function is called.]과 같은 벡터 기반 함수를 이러한 열과 함께 사용할 수 있습니다. 이 `boot_samp` 객체에는 여러 클래스가 있지만 데이터 프레임(`"data.frame"`) 및 티블(`"tbl_df"`)에 대한 메서드를 상속합니다. 또한 데이터 클래스에 영향을 주지 않고 새 열을 결과에 추가할 수 있습니다. 이것은 데이터 구조를 명확하게 하지 않는 완전히 새로운 객체 유형보다 사용자가 훨씬 쉽고 다재다능하게 작업할 수 있습니다.

공통 데이터 구조에 의존할 때에 한 가지 단점은 잠재적인 계산 성능 손실입니다. 경우에 따라 데이터를 보다 효율적으로 표현하는 특수 형식으로 데이터를 인코딩할 수 있습니다. 예를 들어:

 * 계산 화학에서 구조 데이터 파일 형식(SDF;structure-data file format)은 화학 구조를 가져와 계산적으로 효율적인 형식으로 인코딩하는 도구입니다.

 * 동일한 값(예: 이진 데이터의 경우 0)이 많은 데이터는 _희소 행렬 형식(sparse matrix format)_ 으로 저장할 수 있습니다. 이 형식을 사용하면 데이터의 크기를 줄일 수 있을 뿐만 아니라 보다 효율적인 계산 기법을 사용할 수 있습니다.

이러한 형식은 문제의 범위가 충분하고 잠재적인 데이터 처리 방법이 잘 정의되어 있고 이러한 형식에 모두 적합한 경우에 유용합니다^[Not all algorithms can take advantage of sparse representations of data. In such cases, a sparse matrix must be converted to a more conventional format before proceeding.]. 그러나 이러한 제약 조건을 위반하면, 특수 데이터 형식의 유용성이 떨어집니다. 예를 들어, 데이터를 분수로 변환하면 그 출력이 더 이상 희소하지 않습니다. 희소 행렬 표현은 모델링의 특정 알고리즘 단계에서 유용하지만, 특정 단계 이전이나 이후가 아닌 경우가 많습니다.

:::rmdwarning
특수 데이터 구조는 일반적인 데이터 구조처럼 전체 모델링 워크플로우에 대해 유연하지 않습니다. 
:::


`r pkg(rsample)`에 의해 생성된 tibble의 중요한 기능 중 하나는 `splits` 열이 목록이라는 것입니다. 이 경우 목록의 각 요소에는 동일한 개체 유형, 부트스트랩 샘플에 속한 `mtcars` 행에 대한 정보를 포함하는 `rsplit` 객체가 있습니다. _List columns_ 은 데이터 분석에 매우 유용할 수 있으며 이 책 전체에서 볼 수 있듯이 tidymodel에 중요합니다.


### 파이프 및 함수형 프로그래밍을 위한 설계

`r pkg(magrittr)` 파이프 연산자(`% %`)는 일련의 R 함수를 연결하는 도구입니다. 데이터 프레임을 정렬하고 처음 10개 행을 유지하는 다음 명령을 한 번 봅시다.:

```{r tidyverse-no-pipe, eval = FALSE}
small_mtcars <- arrange(mtcars, gear)
small_mtcars <- slice(small_mtcars, 1:10)

# 또는 더 간결하게: 
small_mtcars <- slice(arrange(mtcars, gear), 1:10)
```

파이프 연산자는 연산자의 왼쪽 값을 오른쪽에 대한 첫 번째 인수로 대체하므로 위와 동일한 결과를 다음과 같이 구현할 수 있습니다.: 

```{r tidyverse-pipe, eval = FALSE}
small_mtcars <- 
  mtcars %>% 
  arrange(gear) %>% 
  slice(1:10)
```

파이프 연산자를 사용하면 프로그램의 가독성이 좋아집니다. 시퀀스가 추가될수록 가독성은 증가합니다. 우리가 사용한 모든 함수의 결과는 파이프 다음 함수의 첫 번째 인수가 되고, 동일한 데이터 구조(데이터 프레임)를 반환합니다. 이것은 의도적으로 설계된 것입니다. 가능하면 파이프라인에 통합할 수 있도록 프로그래밍을 하십시오.

`r pkg(ggplot2)`를 사용한 적이 있다면, 파이프 연산자는 `ggplot` 객체에  `+` 연산자를 사용하여 플롯 구성요소를 계층화하는 것과 같습니다. 아래 프로그램은 회귀선이 있는 산점도를 그리기 위해 초기 `ggplot()`에 두 가지 작업이 추가되었습니다.:

```{r tidyverse-ggplot-chain, eval = FALSE}
library(ggplot2)
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() + 
  geom_smooth(method = lm)
```

While similar to the `r pkg(dplyr)` pipeline, note that the first argument to this pipeline is a data set (`mtcars`) and that each function call returns a `ggplot` object. Not all pipelines need to keep the returned values (plot objects) the same as the initial value (a data frame). Using the pipe operator with `r pkg(dplyr)` operations has acclimated many R users to expect to return a data frame when pipelines are used; as shown with `r pkg(ggplot2)`, this does not need to be the case. Pipelines are incredibly useful in modeling workflows but modeling pipelines can return, instead of a data frame, objects such as model components.

R has excellent tools for creating, changing, and operating on functions, making it a great language for _functional programming_. This approach can replace iterative loops in many situations, such as when a function returns a value without other side effects ^[Examples of function side effects could include changing global data or printing a value.]. 

Let's look at an example. Suppose you are interested in the logarithm of the ratio of the fuel efficiency to the car weight. To those new to R and/or coming from other programming languages, a loop might seem like a good option:

```{r tidyverse-loop}
n <- nrow(mtcars)
ratios <- rep(NA_real_, n)
for (car in 1:n) {
  ratios[car] <- log(mtcars$mpg[car]/mtcars$wt[car])
}
head(ratios)
```

Those with more experience in R may know that there is a much simpler and faster _vectorized version_ that can be computed by:

```{r tidyverse-vectorized}
ratios <- log(mtcars$mpg/mtcars$wt)
```

However, in many real-world cases, the element-wise operation of interest is too complex for a vectorized solution. In such a case, a good approach is to write a _function_ to do the computations. When we design for functional programming, it is important that the output only depends on the inputs and that the function has no side effects. Violations of these ideas in the following function are shown with comments:

```{r tidyverse-non-functional}
compute_log_ratio <- function(mpg, wt) {
  log_base <- getOption("log_base", default = exp(1)) # gets external data
  results <- log(mpg/wt, base = log_base)
  print(mean(results))                                # prints to the console
  done <<- TRUE                                       # sets external data
  results
}
```

A better version would be:

```{r tidyverse-better-function}
compute_log_ratio <- function(mpg, wt, log_base = exp(1)) {
  log(mpg/wt, base = log_base)
}
```

The `r pkg(purrr)` package contains tools for functional programming. Let's focus on the `map()` family of functions, which operates on vectors and always returns the same type of output. The most basic function, `map()`, always returns a list and uses the basic syntax of `map(vector, function)`. For example, to take the square-root of our data, we could: 

```{r map-basic}
map(head(mtcars$mpg, 3), sqrt)
``` 

There are specialized variants of `map()` that return values when we know or expect that the function will generate one of the basic vector types. For example, since the square-root returns a double-precision number: 

```{r map-dbl}
map_dbl(head(mtcars$mpg, 3), sqrt)
``` 

There are also mapping functions that operate across multiple vectors: 

```{r map2}
ratios <- map2_dbl(mtcars$mpg, mtcars$wt, compute_log_ratio)
head(ratios)
```

The `map()` functions also allow for temporary, anonymous functions defined using the tilde character. The argument values are `.x` and `.y` for `map2()`:

```{r map2-inline}
map2_dbl(mtcars$mpg, mtcars$wt, ~ log(.x/.y)) %>% 
  head()
```

These examples have been trivial but, in later sections, are applied to more complex problems. 

:::rmdnote
For functional programming in tidy modeling, functions should be defined so that functions like `map()` can be used for iterative computations.
:::


## Examples of tidyverse syntax

Before diving into examples, let's discuss how the tidyverse relies on a type of data frame called a "tibble". Tibbles have slightly different rules than basic data frames in R. For example, tibbles naturally work with column names that are not syntactically valid variable names:

```{r tidyverse-names}
# Wants valid names:
data.frame(`variable 1` = 1:2, two = 3:4)
# But can be coerced to use them with an extra option:
df <- data.frame(`variable 1` = 1:2, two = 3:4, check.names = FALSE)
df

# But tibbles just work:
tbbl <- tibble(`variable 1` = 1:2, two = 3:4)
tbbl
```

Standard data frames enable _partial matching_ of arguments so that code using only a portion of the column names still work. Tibbles prevent this from happening since it can lead to accidental errors. 

```{r tidyverse-partial, error = TRUE}
df$tw

tbbl$tw
```

Tibbles also prevent one of the most common R errors: dropping dimensions. If a standard data frame subsets the columns down to a single column, the object is converted to a vector. Tibbles _never_ do this:

```{r tidyverse-drop}
df[, "two"]

tbbl[, "two"]
```

There are various other advantages to using tibbles instead of data frames, such as better printing and more.  [Chapter 10](https://r4ds.had.co.nz/tibbles.html) of @wickham2016 has more details on tibbles.

```{r tidyverse-import-raw, include = FALSE}
url <- "chi.csv"
train_cols <- 
  cols(
    station_id = col_double(),
    stationname = col_character(),
    date = col_character(),
    daytype = col_character(),
    rides = col_double()
  )
num_combos <- 
  read_delim(url, delim = ",", col_types = train_cols) %>% 
  distinct(date, stationname) %>% 
  nrow()
```

To demonstrate some syntax, let's use tidyverse functions to read in data that could be used in modeling. The data set comes from the city of Chicago's data portal and contains daily ridership data for the city's elevated train stations. The data set has columns for: 

- the station identifier (numeric), 
- the station name (character), 
- the date (character in `mm/dd/yyyy` format), 
- the day of the week (character), and 
- the number of riders (numeric).

Our tidyverse pipeline will conduct the following tasks, in order: 

1. We will use the tidyverse package `r pkg(readr)` to read the data from the source website and convert them into a tibble. To do this, the `read_csv()` function can determine the type of data by reading an initial number of rows. Alternatively, if the column names and types are already known, a column specification can be created in R and passed to `read_csv()`. 

1. We filter the data to eliminate a few columns that are not needed (such as the station ID) and change the column `stationname` to `station`. The function `select()` is used for this. When filtering, use either the names of the column names or a `r pkg(dplyr)` selector function. When selecting names, a new variable name can be declared using the argument format `new_name = old_name`.

1. The date field is converted to the R date format using the `mdy()` function from the `r pkg(lubridate)` package. We also convert the ridership numbers to thousands. Both of these computations are executed using the `dplyr::mutate()` function.  

1. There are a small number of days that have replicate ridership numbers at certain stations. To mitigate this issue, we use the maximum number of rides for each station and day combination. We _group_ the ridership data by station and day, and then _summarize_ within each of the `r num_combos` unique combinations with the maximum statistic. 

The tidyverse code for these steps is:

```{r tidyverse-import, message = FALSE}
library(tidyverse)
library(lubridate)

url <- "http://bit.ly/raw-train-data-csv"

all_stations <- 
  # Step 1: Read in the data.
  read_csv(url) %>% 
  # Step 2: filter columns and rename stationname
  dplyr::select(station = stationname, date, rides) %>% 
  # Step 3: Convert the character date field to a date encoding.
  # Also, put the data in units of 1K rides
  mutate(date = mdy(date), rides = rides / 1000) %>% 
  # Step 4: Summarize the multiple records using the maximum.
  group_by(date, station) %>% 
  summarize(rides = max(rides), .groups = "drop")
```

This pipeline of operations illustrates why the tidyverse is popular. A series of data manipulations is used that have simple and easy to understand user interfaces; the series is bundled together in a streamlined and readable way. The focus is on how the user interacts with the software. This approach enables more people to learn R and achieve their analysis goals, and adopting these same principles for modeling in R has the same benefits. 

## Chapter summary 

This chapter introduced the tidyverse, with a focus on applications for modeling. We described differences in conventions between the tidyverse and base R, and introduced two important components of the tidyverse system, tibbles and the pipe operator `%>%`. Data cleaning and processing can feel mundane at times, but these tasks are important for modeling in the real world; we illustrated how to use tibbles, the pipe, and tidyverse functions in an example data import and processing exercise.  
